// import PptxGenJS from "/jianying-srt/bundle/vendors/pptxgen/pptxgen.es.js";

const primaryElement = document.getElementById("input-text");
const defaultSecondaryElement = document.getElementById("output-temp");
const backgroundImageElement = document.getElementById("uploadBackgroundImage");
const backgroundColorElement = document.getElementById("colorPickerBackground");
const primaryFormElement = document.getElementById("primarySettings");
const secondaryFormElement = document.getElementById("secondarySettings");
const advancedPrimaryOptionElement = document.getElementById(
  "txt-advanced-primary-options"
);
const advancedSecondaryOptionElement = document.getElementById(
  "txt-advanced-secondary-options"
);
const DEFAULT_BACKGROUND_COLOR = "000000";
const DEFAULT_FONT_COLOR = "FFFFFF";
const DEFAULT_AUTHOR = "Howard Lim";
const DEFAULT_SUBJECT = "Lyrics Presentation - Generated by PPT Generator";
const DEFAULT_TITLE = "PPT Generator Presentation";
const DEFAULT_PPT_LAYOUT = "LAYOUT_16x9";
const DEFAULT_LINE_COUNT_PER_ROW = 2;
const LYRIC_POSITION = {
  UPPER: "upper",
  LOWER: "lower",
};
const LYRIC_TYPE = {
  PRIMARY: "primary",
  SECONDARY: "secondary",
};

const DEFAULT_TEXT_OPTION = {
  x: "0%",
  w: "100%",
  bold: true,
  color: DEFAULT_FONT_COLOR,
  fontFace: "Microsoft Yahei",
  fontSize: "48",
  align: "center",
  isTextBox: true,
};

function onGeneratePptClick() {
  // Swal.fire({
  //   title: "Please Wait...",
  //   html: "Generating PPT...",
  //   didOpen: () => {
  //     Swal.showLoading();
  //   },
  // });

  const hasSecondaryContent = !document.getElementById(
    "chbHasIgnoreSecondaryContent"
  ).checked;

  generateFullPpt({ hasSecondaryContent: hasSecondaryContent });
  // Swal.close();
}

// to convert file to data url
function getBase64(file) {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.readAsDataURL(file);
    reader.onload = () => resolve(reader.result);
    reader.onerror = (error) => reject(error);
  });
}

// this function requires pptxgen library imported at the first place
async function generateFullPpt({ hasSecondaryContent = true }) {
  const linePerRow = DEFAULT_LINE_COUNT_PER_ROW;

  const primaryLyric = primaryElement.value;
  const secondaryLyric = document.getElementById("outputPinyin")
    ? document.getElementById("outputPinyin").value
    : defaultSecondaryElement.value;

  const primaryLinesArray = primaryLyric.split("\n");
  const secondaryLinesArray = secondaryLyric.split("\n");

  if (
    hasSecondaryContent &&
    primaryLinesArray.length !== secondaryLinesArray.length &&
    !confirm(
      `主内容有 ${primaryLinesArray.length} 行，而副内容有 ${secondaryLinesArray.length} 行，确定继续吗？`
    )
  ) {
    return;
  }

  // 1. Create a new Presentation
  let pres = new PptxGenJS();
  pres.author = DEFAULT_AUTHOR;
  pres.subject = DEFAULT_SUBJECT;
  pres.title = DEFAULT_TITLE;
  pres.layout = DEFAULT_PPT_LAYOUT;

  // 2. Create Slides Master with Background
  const backgroundProp = await GetPptBackgroundProp();

  pres.defineSlideMaster({
    title: "MASTER_SLIDE",
    background: backgroundProp,
  });

  // 3.0 Get Options
  const customPrimaryOption = GetCustomPrimaryOption();
  const customSecondaryOption = GetCustomSecondaryOption();

  // 3. Create Slides
  primaryLinesArray.forEach((primaryLine, index) => {
    let slide = GetWorkingSlide({ pres, currentIndex: index, linePerRow });

    const currentLyricPosition =
      index % linePerRow == 0 ? LYRIC_POSITION.UPPER : LYRIC_POSITION.LOWER;

    // add primary content
    AddLyricToSlide({
      slide,
      line: primaryLine,
      type: LYRIC_TYPE.PRIMARY,
      lyricPosition: currentLyricPosition,
      primaryOption: customPrimaryOption,
      secondaryOption: customSecondaryOption,
    });

    if (hasSecondaryContent) {
      //add secondary content
      AddLyricToSlide({
        slide,
        line: secondaryLinesArray[index] ?? "",
        type: LYRIC_TYPE.SECONDARY,
        lyricPosition: currentLyricPosition,
        primaryOption: customPrimaryOption,
        secondaryOption: customSecondaryOption,
      });
    }
  });

  //   4. Save the Presentation
  pres.writeFile({ fileName: "Sample Presentation.pptx" });
}

async function GetPptBackgroundProp() {
  const backgroundProp = {
    color: backgroundColorElement?.value ?? DEFAULT_BACKGROUND_COLOR,
  };
  return backgroundImageElement.value !== ""
    ? {
        ...backgroundProp,
        data: await getBase64(backgroundImageElement.files[0]),
      }
    : backgroundProp;
}

function GetCustomPrimaryOption() {
  let option;
  try {
    option = JSON.parse(advancedPrimaryOptionElement.value);
  } catch (err) {
    console.log(err);
    alert(
      "Error in compiling Primary Advanced Option, please check your input"
    );
    return;
  }
  return option;
}

function GetCustomSecondaryOption() {
  let option;
  try {
    option = JSON.parse(advancedSecondaryOptionElement.value);
  } catch (err) {
    console.log(err);
    alert(
      "Error in compiling Secondary Advanced Option, please check your input"
    );
    return;
  }
  return option;
}

function GetWorkingSlide({ pres, currentIndex, linePerRow }) {
  const remainder = currentIndex % linePerRow; //create new slide if remainder is 0
  if (remainder === 0) {
    return pres.addSlide({ masterName: "MASTER_SLIDE" });
  }
  const slidesCount = pres.slides.length;
  return pres.getSlide(slidesCount);
}

function AddLyricToSlide({
  slide,
  line,
  type = LYRIC_TYPE.PRIMARY,
  lyricPosition = LYRIC_POSITION.UPPER,
  primaryOption,
  secondaryOption,
}) {
  let customOption;
  if (type == LYRIC_TYPE.PRIMARY) {
    const customYValue =
      lyricPosition == LYRIC_POSITION.UPPER
        ? primaryOption.y?.upper
        : primaryOption.y?.lower;

    customOption = {
      ...primaryOption,
      y: customYValue,
    };
  } else if (type == LYRIC_TYPE.SECONDARY) {
    const customYValue =
      lyricPosition == LYRIC_POSITION.UPPER
        ? secondaryOption.y?.upper
        : secondaryOption.y?.lower;

    customOption = {
      ...secondaryOption,
      y: customYValue,
    };
  }

  const finalOption = { ...DEFAULT_TEXT_OPTION, ...customOption };
  // had to do like below because somehow the shadow value cannot be parsed correctly

  slide.addText(line, {
    ...finalOption,
    shadow: {
      ...(finalOption.shadow ?? null),
      type: "outer",
      blur: finalOption.shadow?.blur ?? 3,
      offset: finalOption.shadow?.offset ?? 3,
      angle: finalOption.shadow?.angle ?? 45,
      opacity: finalOption.shadow?.opacity ?? 0.5,
    },
  });
}

function onRestoreNormalDefaultOptionClick() {
  const primaryDefaultOption = {
    x: "0%",
    y: {
      upper: "27%",
      lower: "55%",
    },
    bold: true,
    color: "FFFFFF",
    fontFace: "Microsoft Yahei",
    fontSize: 48,
    outline: { size: "0", color: "FFFFFF" },
    shadow: {
      type: "outer",
      color: "000000",
      blur: 3,
      offset: 3,
      angle: 45,
      opacity: "0.5",
    },
    charSpacing: 2,
  };
  const secondaryDefaultOption = {
    x: "0%",
    y: {
      upper: "37%",
      lower: "65%",
    },
    bold: true,
    color: "FFFFFF",
    fontFace: "Microsoft Yahei",
    fontSize: 24, //28 for national park
    outline: { size: "0", color: "FFFFFF" },
    shadow: {
      type: "outer",
      color: "000000",
      blur: 3,
      offset: 3,
      angle: 45,
      opacity: "0.5",
    },
    charSpacing: 0,
  };
  setAdvancedSettings(primaryDefaultOption, secondaryDefaultOption);
  populateSettings(primaryDefaultOption, secondaryDefaultOption);
}

function onRestoreGreenScreenDefaultOptionClick() {
  const primaryDefaultOption = {
    x: "0%",
    y: {
      upper: "84%",
      lower: "55%",
    },
    bold: true,
    color: "FFFFFF",
    fontFace: "Microsoft Yahei",
    fontSize: 30,
    shadow: {
      type: "outer",
      color: "000000",
      blur: 3,
      offset: 3,
      angle: 45,
      opacity: "0.5",
    },
    charSpacing: 2,
  };
  const secondaryDefaultOption = {
    x: "0%",
    y: {
      upper: "92%",
      lower: "65%",
    },
    bold: true,
    color: "FFFFFF",
    fontFace: "Microsoft Yahei",
    fontSize: 18,
    shadow: {
      type: "outer",
      color: "000000",
      blur: 3,
      offset: 3,
      angle: 45,
      opacity: "0.5",
    },
    charSpacing: 0,
  };
  setAdvancedSettings(primaryDefaultOption, secondaryDefaultOption);
  populateSettings(primaryDefaultOption, secondaryDefaultOption);
}

function setAdvancedSettings(primaryOption, secondaryOption) {
  advancedPrimaryOptionElement.value = JSON.stringify(primaryOption, null, 4);
  advancedSecondaryOptionElement.value = JSON.stringify(
    secondaryOption,
    null,
    4
  );
}

function updateLineNumber(textarea, indicator) {
  indicator.innerText = textarea.value
    .substr(0, textarea.selectionStart)
    .split("\n").length;
}

function onExportSettingClick() {
  let primaryOption, secondaryOption;
  try {
    primaryOption = JSON.parse(advancedPrimaryOptionElement.value);
    secondaryOption = JSON.parse(advancedSecondaryOptionElement.value);
  } catch (err) {
    console.log(err);
    alert(
      "Error in compiling Primary Advanced Option, please check your input"
    );
    return;
  }

  const blob = new Blob(
    [
      JSON.stringify({
        advancedPrimaryOption: primaryOption,
        advancedSecondaryOption: secondaryOption,
      }),
    ],
    {
      type: "application/octet-stream",
    }
  );
  const blobUrl = URL.createObjectURL(blob);

  // Create a link element
  const link = document.createElement("a");

  // Set link's href to point to the Blob URL
  link.href = blobUrl;
  link.download = `PptGeneratorSetting-${Date.now()}.json`;

  // Append link to the body
  document.body.appendChild(link);

  // Dispatch click event on the link
  // This is necessary as link.click() does not work on the latest firefox
  link.dispatchEvent(
    new MouseEvent("click", {
      bubbles: true,
      cancelable: true,
      view: window,
    })
  );

  // Remove link from body
  document.body.removeChild(link);
}

function populateFontFaceList({
  dataListId = "fontFaces",
  filePath = "/assets/data/fontFaceList.csv",
}) {
  const host = self.location.host;
  let endpoint = host;
  if (host === "localhost:8080") {
    endpoint = `${self.location.host}/${self.location.pathname.split("/")[1]}`; //for dev purpose
  }

  var requestURL = `http://${endpoint}${filePath}`;
  var xhr = new XMLHttpRequest();
  xhr.onreadystatechange = process;
  xhr.open("GET", requestURL, false);
  xhr.send();

  function process() {
    if (xhr.readyState == 4) {
      const dataListElement = document.querySelector(`#${dataListId}`);
      const fontFaces = xhr.responseText.split(",");

      fontFaces.forEach(function (item) {
        var option = document.createElement("option");
        option.value = item;
        dataListElement.appendChild(option);
      });
    }
  }
}

function initializeSettings() {
  const customPrimaryOption = GetCustomPrimaryOption();
  const customSecondaryOption = GetCustomSecondaryOption();
  populateSettings(customPrimaryOption, customSecondaryOption);
}

function populateSettings(primaryOption, secondaryOption) {
  // set primary option
  primaryFormElement.querySelector("input[name='x']").value =
    primaryOption.x?.replace("%", "");
  primaryFormElement.querySelector("input[name='y-upper']").value =
    primaryOption.y?.upper?.replace("%", "");
  primaryFormElement.querySelector("input[name='y-lower']").value =
    primaryOption.y?.lower?.replace("%", "");
  primaryFormElement.querySelector("input[name='bold']").checked =
    primaryOption.bold;
  primaryFormElement.querySelector("input[name='color']").value =
    "#" + primaryOption.color ?? "FFFFFF";
  primaryFormElement.querySelector("input[name='fontFace']").value =
    primaryOption.fontFace;
  primaryFormElement.querySelector("input[name='fontSize']").value =
    primaryOption.fontSize;
  primaryFormElement.querySelector("input[name='charSpacing']").value =
    primaryOption.charSpacing;
  primaryFormElement.querySelector("input[name='hasGlow']").checked =
    primaryOption.glow;
  primaryFormElement.querySelector("input[name='glow-size']").value =
    primaryOption.glow?.size;
  primaryFormElement.querySelector("input[name='glow-color']").value =
    "#" + (primaryOption.glow?.color ?? "000000");

  primaryFormElement.querySelector("input[name='hasOutline']").checked =
    primaryOption.outline;
  primaryFormElement.querySelector("input[name='outline-size']").value =
    primaryOption.outline?.size;
  primaryFormElement.querySelector("input[name='outline-color']").value =
    "#" + (primaryOption.outline?.color ?? "000000");

  primaryFormElement.querySelector("input[name='hasShadow']").checked =
    primaryOption.shadow;
  primaryFormElement.querySelector("select[name='shadow-type']").value =
    primaryOption.shadow?.type;
  primaryFormElement.querySelector("input[name='shadow-color']").value =
    "#" + (primaryOption.shadow?.color ?? "000000");
  primaryFormElement.querySelector("input[name='shadow-blur']").value =
    primaryOption.shadow?.blur;
  primaryFormElement.querySelector("input[name='shadow-offset']").value =
    primaryOption.shadow?.offset;
  primaryFormElement.querySelector("input[name='shadow-angle']").value =
    primaryOption.shadow?.angle;
  primaryFormElement.querySelector("input[name='shadow-opacity']").value =
    primaryOption.shadow?.opacity;

  // set secondary option
  secondaryFormElement.querySelector("input[name='x']").value =
    secondaryOption.x?.replace("%", "");
  secondaryFormElement.querySelector("input[name='y-upper']").value =
    secondaryOption.y?.upper?.replace("%", "");
  secondaryFormElement.querySelector("input[name='y-lower']").value =
    secondaryOption.y?.lower?.replace("%", "");
  secondaryFormElement.querySelector("input[name='bold']").checked =
    secondaryOption.bold;
  secondaryFormElement.querySelector("input[name='color']").value =
    "#" + secondaryOption.color ?? "FFFFFF";
  secondaryFormElement.querySelector("input[name='fontFace']").value =
    secondaryOption.fontFace;
  secondaryFormElement.querySelector("input[name='fontSize']").value =
    secondaryOption.fontSize;
  secondaryFormElement.querySelector("input[name='charSpacing']").value =
    secondaryOption.charSpacing;
  secondaryFormElement.querySelector("input[name='hasGlow']").checked =
    secondaryOption.glow;
  secondaryFormElement.querySelector("input[name='glow-size']").value =
    secondaryOption.glow?.size;
  secondaryFormElement.querySelector("input[name='glow-color']").value =
    "#" + (secondaryOption.glow?.color ?? "000000");

  secondaryFormElement.querySelector("input[name='hasOutline']").checked =
    secondaryOption.outline;
  secondaryFormElement.querySelector("input[name='outline-size']").value =
    secondaryOption.outline?.size;
  secondaryFormElement.querySelector("input[name='outline-color']").value =
    "#" + (secondaryOption.outline?.color ?? "000000");

  secondaryFormElement.querySelector("input[name='hasShadow']").checked =
    secondaryOption.shadow;
  secondaryFormElement.querySelector("select[name='shadow-type']").value =
    secondaryOption.shadow?.type;
  secondaryFormElement.querySelector("input[name='shadow-color']").value =
    "#" + (secondaryOption.shadow?.color ?? "000000");
  secondaryFormElement.querySelector("input[name='shadow-blur']").value =
    secondaryOption.shadow?.blur;
  secondaryFormElement.querySelector("input[name='shadow-offset']").value =
    secondaryOption.shadow?.offset;
  secondaryFormElement.querySelector("input[name='shadow-angle']").value =
    secondaryOption.shadow?.angle;
  secondaryFormElement.querySelector("input[name='shadow-opacity']").value =
    secondaryOption.shadow?.opacity;
}

function onApplySettingsClick() {
  let formData = new FormData(primaryFormElement);

  let primaryOption = {
    x: `${formData.get("x")}%`,
    y: {
      upper: `${formData.get("y-upper")}%`,
      lower: `${formData.get("y-lower")}%`,
    },
    bold: !!formData.get("bold"),
    color: formData.get("color")?.replace("#", "") ?? "FFFFFF",
    fontFace: formData.get("fontFace") ?? "Microsoft Yahei",
    fontSize: formData.get("fontSize") ?? 48,
    charSpacing: formData.get("charSpacing") ?? 2,
  };
  if (formData.get("hasGlow")) {
    primaryOption = {
      ...primaryOption,
      glow: {
        size: formData.get("glow-size") ?? 5,
        color: formData.get("glow-color")?.replace("#", "") ?? "FFFFFF",
      },
    };
  }
  if (formData.get("hasOutline")) {
    primaryOption = {
      ...primaryOption,
      outline: {
        size: formData.get("outline-size") ?? 1,
        color: formData.get("outline-color")?.replace("#", "") ?? "FFFFFF",
      },
    };
  }
  if (formData.get("hasShadow")) {
    primaryOption = {
      ...primaryOption,
      shadow: {
        type: formData.get("shadow-type") ?? "outer",
        color: formData.get("shadow-color")?.replace("#", "") ?? "000000",
        blur: formData.get("shadow-blur") ?? 3,
        offset: formData.get("shadow-offset") ?? 3,
        angle: formData.get("shadow-angle") ?? 45,
        opacity: formData.get("shadow-opacity") ?? "0.5",
      },
    };
  }
  formData = new FormData(secondaryFormElement);
  let secondaryOption = {
    x: `${formData.get("x")}%`,
    y: {
      upper: `${formData.get("y-upper")}%`,
      lower: `${formData.get("y-lower")}%`,
    },
    bold: !!formData.get("bold"),
    color: formData.get("color")?.replace("#", "") ?? "FFFFFF",
    fontFace: formData.get("fontFace") ?? "Microsoft Yahei",
    fontSize: formData.get("fontSize") ?? 48,
    charSpacing: formData.get("charSpacing") ?? 2,
  };
  if (formData.get("hasGlow")) {
    secondaryOption = {
      ...secondaryOption,
      glow: {
        size: formData.get("glow-size") ?? 5,
        color: formData.get("glow-color")?.replace("#", "") ?? "FFFFFF",
      },
    };
  }
  if (formData.get("hasOutline")) {
    secondaryOption = {
      ...secondaryOption,
      outline: {
        size: formData.get("outline-size") ?? 1,
        color: formData.get("outline-color")?.replace("#", "") ?? "FFFFFF",
      },
    };
  }
  if (formData.get("hasShadow")) {
    secondaryOption = {
      ...secondaryOption,
      shadow: {
        type: formData.get("shadow-type") ?? "outer",
        color: formData.get("shadow-color")?.replace("#", "") ?? "000000",
        blur: formData.get("shadow-blur") ?? 3,
        offset: formData.get("shadow-offset") ?? 3,
        angle: formData.get("shadow-angle") ?? 45,
        opacity: formData.get("shadow-opacity") ?? "0.5",
      },
    };
  }

  setAdvancedSettings(primaryOption, secondaryOption);
  alert("Successfully applied setting");
}

(function () {
  var uploadElement = document.querySelector("#uploadSetting");

  uploadElement.addEventListener("change", function (event) {
    const fileExtension = event.target.value.split(".").pop();
    if (fileExtension !== "json") {
      alert("Invalid settings file");
      return;
    }
    readSettingsFile(event.target.files[0]);
  });

  function readSettingsFile(file) {
    var fileReader = new FileReader();
    fileReader.onload = function (event) {
      let importedSettings;
      try {
        importedSettings = JSON.parse(event.target.result);
      } catch (error) {
        console.log(err);
        alert("Error in compiling imported option, please check your file");
        return;
      }

      if (
        !importedSettings?.advancedPrimaryOption ||
        !importedSettings?.advancedSecondaryOption
      ) {
        alert("Invalid settings");
        return;
      }
      alert("Imported Successfully");

      setAdvancedSettings(
        importedSettings?.advancedPrimaryOption,
        importedSettings?.advancedSecondaryOption
      );

      populateSettings(
        importedSettings?.advancedPrimaryOption,
        importedSettings?.advancedSecondaryOption
      );
      // reset back to empty, else cannot uploading same file cannot trigger on change
      document.querySelector("#uploadSetting").value = "";
    };
    fileReader.readAsText(file);
    fileReader = null;
  }
})();

//set default settings
$(document).ready(function () {
  onRestoreNormalDefaultOptionClick();
  populateFontFaceList({
    dataListId: "fontFaces",
    filePath: "/assets/data/fontFaceList.csv",
  });
  initializeSettings();
});
